<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="textBox1.Text" xml:space="preserve">
    <value>1- در ابتدا مقدار اسکیل ترسیمات را پیدا کنید. برای مثال فاصله افست لبه کناری کار تا آکس مسیر را با مقدار درج شده در ترسیم مقایسه کنید. خروجی نرم افزار معمولا هزار برابر تنظیم شده است. اگر ترسیمات رو مقیاس دهی کردید در باکس مقیاس یک به یک که مقدار پیش فرض 200 درج شده است را باید براساس سکشنی که تغییر مقیاس داده اید درج کنید. برای مثال شما یکی از شیت هایی که سکشن ها در آن ترسیم شده است را انتخاب می کنید و اندازه گیری را انجام میدهید و بر اساس اندازه ای که بدست آوردید به کل سکشنها مقیاسی میدهید تا سایر شیت ها بر اساس اولین شیت مقیاس دهی بشوند و مقیاس اولین شیت شما هم یک به یک می شود. بعد از اینکار مقیاسی که در سمت چپ پایین شیت اول نوشته شده است را باید در باکس مربوط به مقیاس یک به یک تایپ کنید 
2- در یک شیت در مرحله بعد باید تکست کیلومتراژ مسیر را انتخاب کنید. اگر کیلومتراژ دارای دو تکست متفاوت بود در ابتدا تکست سمت چپ و بعد تکست سمت راست را انتخاب نمایید و اگر یک تکست بود تنها همان تکست را انتخاب نمایید. توجه نمایید که بعد از انتخاب تکست ها باید مقدار صحیح در لیبل مورد نظر درج شود
3- در مراحل بعدی پلی لاین سطح زمین طبیعی و سطح نهایی را انتخاب نمایید. توجه کنید که تمامی انتخاب ها در یک کیلومتراژ و در یک شیت باشند و از شیت های مختلف انتخاب نشوند
4- در آخر هم کادر دور شیت انتخاب شود و سپس تمامی ترسیمات انتخاب شده و دکمه ایجاد فایل را بزنید و فایل تکست را ذخیره نمایید
5-برنامه ای جداگانه برای ترسیم سکشن ها برای همین منظور در همین فایل نوشته شده است و می توانید از آن برای تولید سکشن های سیویل استفاده نمایید
6-نکته آخر اینکه اگر خطوط زمین و آسفالت بصورت پلی لاین یک تیکه بودش باید تیک باکس پلی لاین چندتیکه رو بردارید و در غیر اینصورت تیک را بزنید و همچنین اگر سطح نهایی در یک طرف آکس قرار داره و تیکه دومی در سمت راست یا چپ نداشته باشد باید تیک گزینه تریم رو بزنید
</value>
  </data>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="$this.Icon" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        AAABAAEAICAQAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAgICAAMDAwAAAAP8AAP8AAAD//wD/AAAA/wD/AP//
        AAD///8AAAAAAAAAAAC6q6qqqqqqqgAAAAAAAAALqrqru7u7u7sAAAAAAAAAuququqqqqqqqAAAAAAAA
        C6q6q6qqqqqqqgAAAAAAALqrqrqru7u7u7sAAAAAAAuququqsRERERERAAAAAAC6q6q6qxEREREREQAA
        AAALqrqrqrB+cREREREAAAAAuququqsH7ucRERERAAAAC6q6q6qwfu7ncREREQAAALqrqrqrB+7uAHcR
        EREAAAuququqsH7u7gB+cRERAAC6q3REREfu7ncAd3cREQALqrp3RPREfuAAAAAHcREAuquqfnRPREfw
        AAAADucRC6q6qn7nRPREf/8Af+7ucXRERER+7nREREfvAH7u7ucHRE9ER+7nREREfwDu7u7uAHRE9ER+
        7nRPREf+7u7u7gAHRE9ER+7nRPREfu7u7u4AAHRERER+7nRPREfu7u7uAAAHRERER+7nREREfu7u7gAA
        AHRE9ER+7nREREfu7u4AAAAHRE9ER+7nRPREfu7uALuwAHS09ER+7nRPREfu7gsACwAHtERER+7nRPRE
        fu6wAAsLu7tERER+7nREREfnsAu7CwC3RE9ER+7nREREcLAAAACwsHRE9ER+5wAAAACwAAsAsLAHRE9E
        R+cAAAAACwALAAuwAHRERER3AAAAAAC7sAAAsAAHRERERwAAAAD//wAA//4AAP/8AAD/+AAA//AAAP/g
        AAD/wAAA/4AQAP8AIAD+AEAA/ACAAPgBAADwAAAA4AAAAMAAAACAAAAAAAAAAIAAAADAAAAA4AAAAPAA
        AAD4AAAA/AAAAP4AAADHAAAAu4AAAHoAAABiwAABf1AA/3tYAP+7nAD/x94A/w==
</value>
  </data>
</root>